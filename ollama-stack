#!/bin/bash
# Ollama Stack - Unified CLI Tool
# Combines stack management and extension management into a single interface

set -e

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
EXTENSIONS_DIR="$SCRIPT_DIR/extensions"
REGISTRY_FILE="$EXTENSIONS_DIR/registry.json"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color
CYAN='\033[0;36m'

# Function to print colored output
print_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

print_header() {
    local message=$1
    echo ""
    print_color $WHITE "==== $message ===="
}

print_status() {
    print_color $CYAN "[*] $1"
}

print_success() {
    print_color $GREEN "[+] $1"
}

print_error() {
    print_color $RED "[-] $1"
}

print_warning() {
    print_color $YELLOW "[!] $1"
}

# Platform detection
detect_platform() {
    # Check for Apple Silicon
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if [[ $(uname -m) == "arm64" ]]; then
            echo "apple"
            return
        fi
    fi
    
    # Check for NVIDIA GPU
    if command -v nvidia-smi >/dev/null 2>&1; then
        if nvidia-smi >/dev/null 2>&1; then
            echo "nvidia"
            return
        fi
    fi
    
    # Default to CPU
    echo "cpu"
}

# Check for available updates
check_for_updates() {
    local platform="$1"
    
    # Simple check: if images are older than 7 days, suggest update
    local old_images=()
    
    # Check core images based on platform
    local images_to_check=()
    if [ "$platform" != "apple" ]; then
        images_to_check+=("ollama/ollama:latest")
    fi
    images_to_check+=("ghcr.io/open-webui/open-webui:main" "ghcr.io/open-webui/mcpo:main")
    
    for image in "${images_to_check[@]}"; do
        # Check if image is older than 7 days using simple find-like logic
        if docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedSince}}" | grep -q "$image.*[8-9] days ago\|[1-9][0-9] days ago\|[1-9] weeks ago\|[1-9] months ago"; then
            local service_name=$(echo "$image" | cut -d'/' -f2- | cut -d':' -f1)
            old_images+=("$service_name")
        fi
    done
    
    # Display simple notification if old images found
    if [ ${#old_images[@]} -gt 0 ]; then
        print_warning "Some images may have updates available"
        print_status "Run 'ollama-stack update' to get the latest versions"
    fi
}

# Check if Docker is running
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running. Please start Docker and try again."
        exit 1
    fi
}

# Wait for service health
wait_for_service() {
    local service_name=$1
    local url=$2
    local max_wait=${3:-120}
    
    print_status "Waiting for $service_name to be ready..."
    local elapsed=0
    
    while [ $elapsed -lt $max_wait ]; do
        if curl -s -f "$url" >/dev/null 2>&1; then
            print_success "$service_name ready!"
            return 0
        fi
        
        sleep 5
        elapsed=$((elapsed + 5))
        print_status "Still waiting... ($elapsed/$max_wait seconds)"
    done
    
    print_error "$service_name failed to start within $max_wait seconds"
    return 1
}

# Get compose files for platform
get_compose_files() {
    local platform=$1
    local compose_files=("-f" "docker-compose.yml")
    
    case $platform in
        nvidia)
            compose_files+=("-f" "docker-compose.nvidia.yml")
            ;;
        apple)
            compose_files+=("-f" "docker-compose.apple.yml")
            ;;
    esac
    
    echo "${compose_files[@]}"
}

# Extension management functions
get_extensions() {
    if [ ! -f "$REGISTRY_FILE" ]; then
        echo "[]"
        return
    fi
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
    print(json.dumps(list(data.get('extensions', {}).keys())))
except:
    print('[]')
"
}

get_enabled_extensions() {
    if [ ! -f "$REGISTRY_FILE" ]; then
        echo "[]"
        return
    fi
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
    print(json.dumps(data.get('enabled', [])))
except:
    print('[]')
"
}

is_extension_enabled() {
    local extension=$1
    local enabled_list=$(get_enabled_extensions)
    echo "$enabled_list" | python3 -c "
import json, sys
enabled = json.load(sys.stdin)
print('true' if '$extension' in enabled else 'false')
"
}

update_registry() {
    local extension=$1
    local action=$2  # enable or disable
    
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
except:
    data = {'version': '1.0', 'extensions': {}, 'enabled': []}

enabled = data.get('enabled', [])
if '$action' == 'enable' and '$extension' not in enabled:
    enabled.append('$extension')
elif '$action' == 'disable' and '$extension' in enabled:
    enabled.remove('$extension')

data['enabled'] = enabled

with open('$REGISTRY_FILE', 'w') as f:
    json.dump(data, f, indent=2)
"
}

# Command implementations

cmd_start() {
    local platform="auto"
    local skip_models=false
    local auto_update=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                if [[ ! "$platform" =~ ^(auto|cpu|nvidia|apple)$ ]]; then
                    print_error "Platform must be 'auto', 'cpu', 'nvidia', or 'apple'"
                    exit 1
                fi
                shift 2
                ;;
            -s|--skip-models)
                skip_models=true
                shift
                ;;
            -u|--update)
                auto_update=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    print_header "Starting Ollama Stack"
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
        print_status "Auto-detected platform: $platform"
    else
        print_status "Using specified platform: $platform"
    fi
    
    check_docker
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    case $platform in
        nvidia)
            print_status "Using NVIDIA GPU acceleration"
            ;;
        apple)
            print_status "Using Apple Silicon configuration"
            print_warning "Make sure native Ollama app is running!"
            ;;
        cpu)
            print_status "Using CPU-only configuration"
            ;;
    esac
    
    # Start core stack
    print_status "Starting core stack..."
    
    # Pull latest images if update flag is set
    if [ "$auto_update" = "true" ]; then
        print_status "Pulling latest images..."
        if ! docker compose "${compose_files[@]}" pull; then
            print_warning "Failed to pull some images, continuing with existing images..."
        fi
    fi
    
    if ! docker compose "${compose_files[@]}" up -d; then
        print_error "Failed to start core stack"
        exit 1
    fi
    
    # Wait for services
    print_status "Waiting for core services..."
    
    # Always check Ollama health - it's required for Open WebUI
    wait_for_service "Ollama" "http://localhost:11434"
    
    wait_for_service "Open WebUI" "http://localhost:8080"
    wait_for_service "MCP Proxy" "http://localhost:8200/docs"
    
    print_header "Stack Started Successfully!"
    print_status "Services:"
    print_success "  • Open WebUI: http://localhost:8080"
    print_success "  • Ollama API: http://localhost:11434"
    print_success "  • MCP Proxy: http://localhost:8200"
    print_success "  • MCP Docs: http://localhost:8200/docs"
    print_success "Ready! Visit http://localhost:8080 to get started."
    
    # Check for updates if we didn't just update
    if [ "$auto_update" != "true" ]; then
        check_for_updates "$platform"
    fi
}

cmd_stop() {
    local platform="auto"
    local remove_volumes=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                shift 2
                ;;
            -v|--remove-volumes)
                remove_volumes=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    print_header "Stopping Ollama Stack"
    
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    
    check_docker
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    # Build command
    local compose_cmd=("docker" "compose" "${compose_files[@]}")
    
    if [ "$remove_volumes" = true ]; then
        print_warning "Removing volumes (all data will be deleted)..."
        compose_cmd+=("down" "-v")
    else
        compose_cmd+=("down")
    fi
    
    # Execute
    if "${compose_cmd[@]}"; then
        print_success "Stack stopped successfully"
        if [ "$remove_volumes" = true ]; then
            print_success "Volumes removed successfully"
        fi
    else
        print_error "Failed to stop stack"
        exit 1
    fi
}

cmd_status() {
    print_header "Ollama Stack Status"
    
    # Check Docker
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running"
        return 1
    fi
    
    # Check core services
    print_status "Core Services:"
    docker compose ps --format "table {{.Service}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || print_warning "No core services running"
    
    # Check extensions
    print_status "Extensions:"
    cmd_extensions_list
}

cmd_logs() {
    local service=""
    local follow=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                service="$1"
                shift
                ;;
        esac
    done
    
    if [ -z "$service" ]; then
        # Show all logs
        if [ "$follow" = true ]; then
            docker compose logs -f
        else
            docker compose logs
        fi
    else
        # Show specific service logs
        if [ "$follow" = true ]; then
            docker compose logs -f "$service"
        else
            docker compose logs "$service"
        fi
    fi
}

cmd_extensions() {
    local subcommand="$1"
    shift
    
    case $subcommand in
        list|ls)
            cmd_extensions_list "$@"
            ;;
        enable)
            cmd_extensions_enable "$@"
            ;;
        disable)
            cmd_extensions_disable "$@"
            ;;
        start)
            cmd_extensions_start "$@"
            ;;
        stop)
            cmd_extensions_stop "$@"
            ;;
        restart)
            cmd_extensions_restart "$@"
            ;;
        logs)
            cmd_extensions_logs "$@"
            ;;
        info)
            cmd_extensions_info "$@"
            ;;
        *)
            print_error "Unknown extensions subcommand: $subcommand"
            echo ""
            echo "Available subcommands:"
            echo "  list, ls       List all extensions"
            echo "  enable <ext>   Enable an extension"
            echo "  disable <ext>  Disable an extension"
            echo "  start <ext>    Start an extension"
            echo "  stop <ext>     Stop an extension"
            echo "  restart <ext>  Restart an extension"
            echo "  logs <ext>     View extension logs"
            echo "  info <ext>     Show extension information"
            exit 1
            ;;
    esac
}

cmd_extensions_list() {
    if [ ! -d "$EXTENSIONS_DIR" ]; then
        print_warning "Extensions directory not found"
        return 1
    fi
    
    for ext_dir in "$EXTENSIONS_DIR"/*/; do
        if [ -d "$ext_dir" ]; then
            local ext_name=$(basename "$ext_dir")
            
            # Skip manage.sh and other files
            if [ "$ext_name" = "manage.sh" ] || [ "$ext_name" = "registry.json" ]; then
                continue
            fi
            
            local enabled=$(is_extension_enabled "$ext_name")
            local status_icon="[DISABLED]"
            local status_text="disabled"
            
            if [ "$enabled" = "true" ]; then
                status_icon="[ENABLED]"
                status_text="enabled"
                
                # Check if running
                if docker ps --format "table {{.Names}}" | grep -q "^$ext_name\$"; then
                    status_icon="[RUNNING]"
                    status_text="running"
                fi
            fi
            
            print_status "  $status_icon $ext_name ($status_text)"
            
            # Get description
            if [ -f "$ext_dir/mcp-config.json" ]; then
                local desc=$(python3 -c "
import json
try:
    with open('$ext_dir/mcp-config.json', 'r') as f:
        data = json.load(f)
    print(data.get('description', ''))
except:
    pass
" 2>/dev/null)
                if [ -n "$desc" ]; then
                    print_status "      $desc"
                fi
            fi
        fi
    done
}

cmd_extensions_enable() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "true" ]; then
        print_warning "Extension '$extension' is already enabled"
        return 0
    fi
    
    update_registry "$extension" "enable"
    print_success "Extension '$extension' enabled"
}

cmd_extensions_disable() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "false" ]; then
        print_warning "Extension '$extension' is already disabled"
        return 0
    fi
    
    # Stop if running
    if docker ps --format "table {{.Names}}" | grep -q "^$extension\$"; then
        cmd_extensions_stop "$extension"
    fi
    
    update_registry "$extension" "disable"
    print_success "Extension '$extension' disabled"
}

cmd_extensions_start() {
    local extension="$1"
    local platform="auto"
    
    # Parse arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                shift 2
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "false" ]; then
        print_error "Extension '$extension' is not enabled. Enable it first with: ollama-stack extensions enable $extension"
        exit 1
    fi
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    
    print_status "Starting extension '$extension' with $platform configuration..."
    
    # Change to extension directory
    cd "$EXTENSIONS_DIR/$extension"
    
    # Get compose files
    local compose_files=("-f" "docker-compose.yml")
    case $platform in
        nvidia)
            if [ -f "docker-compose.nvidia.yml" ]; then
                compose_files+=("-f" "docker-compose.nvidia.yml")
            fi
            ;;
        apple)
            if [ -f "docker-compose.apple.yml" ]; then
                compose_files+=("-f" "docker-compose.apple.yml")
            fi
            ;;
    esac
    
    # Start extension
    if docker compose "${compose_files[@]}" up -d; then
        print_success "Extension '$extension' started successfully"
    else
        print_error "Failed to start extension '$extension'"
        exit 1
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_stop() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    print_status "Stopping extension '$extension'..."
    
    cd "$EXTENSIONS_DIR/$extension"
    
    if docker compose down; then
        print_success "Extension '$extension' stopped successfully"
    else
        print_error "Failed to stop extension '$extension'"
        exit 1
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_restart() {
    local extension="$1"
    shift
    
    cmd_extensions_stop "$extension"
    cmd_extensions_start "$extension" "$@"
}

cmd_extensions_logs() {
    local extension="$1"
    local follow=false
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    cd "$EXTENSIONS_DIR/$extension"
    
    if [ "$follow" = true ]; then
        docker compose logs -f
    else
        docker compose logs
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_info() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    print_header "Extension Information: $extension"
    
    # Read MCP config
    local config_file="$EXTENSIONS_DIR/$extension/mcp-config.json"
    if [ -f "$config_file" ]; then
        python3 -c "
import json
try:
    with open('$config_file', 'r') as f:
        data = json.load(f)
    
    print(f\"Name: {data.get('displayName', 'N/A')}\")
    print(f\"Version: {data.get('version', 'N/A')}\")
    print(f\"Type: {data.get('type', 'N/A')}\")
    print(f\"Description: {data.get('description', 'N/A')}\")
    print()
    
    # MCP info
    mcp = data.get('mcp', {})
    caps = mcp.get('capabilities', {})
    print('MCP Configuration:')
    print(f\"  Server Name: {mcp.get('serverName', 'N/A')}\")
    print(f\"  Transport: {mcp.get('transport', 'N/A')}\")
    print(f\"  Tools: {'Yes' if caps.get('tools') else 'No'}\")
    print(f\"  Resources: {'Yes' if caps.get('resources') else 'No'}\")
    print(f\"  Prompts: {'Yes' if caps.get('prompts') else 'No'}\")
    print()
    
    # Platform support
    platforms = data.get('platforms', {})
    print('Platform Support:')
    for platform, info in platforms.items():
        supported = 'Yes' if info.get('supported', False) else 'No'
        perf = info.get('performance', 'unknown')
        print(f\"  {platform}: {supported} (performance: {perf})\")
    print()
    
    # Requirements
    reqs = data.get('requirements', {})
    if reqs:
        print('Requirements:')
        for req, desc in reqs.items():
            if isinstance(desc, dict):
                req_text = desc.get('description', str(desc))
                required = ' (required)' if desc.get('required', False) else ''
                print(f\"  {req}: {req_text}{required}\")
            else:
                print(f\"  {req}: {desc}\")
        print()
    
except Exception as e:
    print(f'Error reading config: {e}')
"
    fi
    
    # Status
    local enabled=$(is_extension_enabled "$extension")
    local running="No"
    if docker ps --format "table {{.Names}}" | grep -q "^$extension\$"; then
        running="Yes"
    fi
    
    print_status "Status:"
    print_status "  Enabled: $([ "$enabled" = "true" ] && echo "Yes" || echo "No")"
    print_status "  Running: $([ "$running" = "Yes" ] && echo "Yes" || echo "No")"
}

cmd_uninstall() {
    local force=false
    local remove_volumes=false
    local remove_images=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--force)
                force=true
                shift
                ;;
            --remove-volumes)
                remove_volumes=true
                shift
                ;;
            --remove-images)
                remove_images=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Usage: ollama-stack uninstall [--force] [--remove-volumes] [--remove-images]"
                exit 1
                ;;
        esac
    done
    
    print_header "Ollama Stack Uninstall"
    
    # Detect if we're running from an installed location
    local is_installed=false
    local install_type=""
    local install_path=""
    local project_path=""
    
    # Check common installation locations
    if [[ "$SCRIPT_DIR" == "/usr/local/share/ollama-stack" || "$SCRIPT_DIR" == "$HOME/.local/share/ollama-stack" ]]; then
        is_installed=true
        project_path="$SCRIPT_DIR"
        if [[ "$SCRIPT_DIR" == "/usr/local/share/ollama-stack" ]]; then
            install_type="system"
            install_path="/usr/local/bin/ollama-stack"
        else
            install_type="user"
            install_path="$HOME/.local/bin/ollama-stack"
        fi
    fi
    
    if [ "$force" != "true" ]; then
        print_warning "This will completely remove the Ollama Stack:"
        print_status "  • Stop all running containers"
        print_status "  • Remove all containers"
        if [ "$remove_images" = "true" ]; then
            print_status "  • Remove all Docker images"
        else
            print_success "  • Keep Docker images (faster future installs)"
        fi
        print_status "  • Remove Docker network"
        if [ "$remove_volumes" = "true" ]; then
            print_error "  • Remove all volumes (DELETES ALL DATA!)"
        else
            print_success "  • Keep volumes (data preserved)"
        fi
        print_status "  • Disable all extensions"
        
        if [ "$is_installed" = "true" ]; then
            print_status "  • Remove installation files"
            print_status "  • Remove ollama-stack command"
            print_status "  • Clean up shell PATH modifications"
        fi
        
        read -p "Are you sure you want to continue? (y/N): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_success "Uninstall cancelled."
            exit 0
        fi
    fi
    
    # Stop all services first
    print_status "Stopping all services..."
    cmd_stop --platform auto
    
    # Stop and remove extension containers
    print_status "Stopping and removing extension containers..."
    for extension_dir in "$EXTENSIONS_DIR"/*; do
        if [ -d "$extension_dir" ]; then
            extension=$(basename "$extension_dir")
            if [ -f "$extension_dir/docker-compose.yml" ]; then
                print_status "  Removing extension: $extension"
                cd "$extension_dir"
                docker compose down --remove-orphans 2>/dev/null || true
                cd "$SCRIPT_DIR"
                
                # Disable extension
                update_registry "$extension" "disable"
            fi
        fi
    done
    
    # Remove main stack containers
    print_status "Removing main stack containers..."
    docker compose down --remove-orphans 2>/dev/null || true
    
    # Remove images if requested
    if [ "$remove_images" = "true" ]; then
        print_status "Removing Docker images..."
        local images_to_remove=(
            "ollama/ollama"
            "ghcr.io/open-webui/open-webui"
            "ghcr.io/open-webui/mcpo"
        )
        
        for image in "${images_to_remove[@]}"; do
            if docker images --format "table {{.Repository}}:{{.Tag}}" | grep -q "^$image"; then
                print_status "  Removing image: $image"
                docker rmi $(docker images "$image" -q) 2>/dev/null || true
            fi
        done
        
        # Remove extension images
        for extension_dir in "$EXTENSIONS_DIR"/*; do
            if [ -d "$extension_dir" ]; then
                extension=$(basename "$extension_dir")
                if docker images --format "table {{.Repository}}:{{.Tag}}" | grep -q "^$extension"; then
                    print_status "  Removing extension image: $extension"
                    docker rmi $(docker images "$extension" -q) 2>/dev/null || true
                fi
            fi
        done
    else
        print_status "Keeping Docker images for faster future installs..."
    fi
    
    # Remove volumes
    if [ "$remove_volumes" = "true" ]; then
        print_status "Removing volumes..."
        local volumes_to_remove=(
            "ollama_data"
            "webui_data"
        )
        
        for volume in "${volumes_to_remove[@]}"; do
            if docker volume ls --format "table {{.Name}}" | grep -q "^$volume\$"; then
                print_status "  Removing volume: $volume"
                docker volume rm "$volume" 2>/dev/null || true
            fi
        done
        
        # Remove extension volumes
        for extension_dir in "$EXTENSIONS_DIR"/*; do
            if [ -d "$extension_dir" ]; then
                extension=$(basename "$extension_dir")
                # Look for volumes with extension name prefix
                docker volume ls --format "table {{.Name}}" | grep "^${extension}" | while read -r volume; do
                    if [ ! -z "$volume" ]; then
                        print_status "  Removing extension volume: $volume"
                        docker volume rm "$volume" 2>/dev/null || true
                    fi
                done
            fi
        done
    fi
    
    # Remove network
    print_status "Removing Docker network..."
    if docker network ls --format "table {{.Name}}" | grep -q "^ollama-stack-network\$"; then
        docker network rm ollama-stack-network 2>/dev/null || true
    fi
    
    # Clean up any remaining containers
    print_status "Cleaning up remaining containers..."
    docker container prune -f 2>/dev/null || true
    
    # Clean up installation files if installed
    if [ "$is_installed" = "true" ]; then
        print_status "Removing installation files..."
        
        # Remove the wrapper script
        if [ -f "$install_path" ]; then
            print_status "  Removing command: $install_path"
            rm -f "$install_path" 2>/dev/null || true
        fi
        
        # Clean up shell PATH modifications
        if [ "$install_type" = "user" ]; then
            print_status "  Cleaning up shell PATH modifications"
            local bin_dir="$(dirname "$install_path")"
            
            # Remove from common shell config files
            for config_file in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
                if [ -f "$config_file" ] && grep -q "$bin_dir" "$config_file"; then
                    print_status "    Removing from $(basename "$config_file")"
                    # Remove the export line and the comment above it
                    sed -i.bak '/# Added by ollama-stack installer/,+1d' "$config_file" 2>/dev/null || true
                    rm -f "$config_file.bak" 2>/dev/null || true
                fi
            done
        fi
        
        # Remove project files (this will remove the directory we're running from)
        # We need to do this last and handle it carefully
        if [ -d "$project_path" ]; then
            print_status "  Removing project files: $project_path"
            
            # Create a temporary cleanup script to remove the project directory
            # after this script exits
            local cleanup_script="/tmp/ollama-stack-cleanup-$$"
            cat > "$cleanup_script" << EOF
#!/bin/bash
sleep 1
rm -rf "$project_path" 2>/dev/null || true
rm -f "$cleanup_script" 2>/dev/null || true
EOF
            chmod +x "$cleanup_script"
            nohup "$cleanup_script" >/dev/null 2>&1 &
        fi
    fi
    
    print_success "Ollama Stack uninstall completed!"
    if [ "$remove_volumes" != "true" ]; then
        print_warning "Note: Data volumes were preserved. Use 'docker volume ls' to see them."
    fi
    
    if [ "$is_installed" = "true" ]; then
        print_success "Installation files removed!"
        print_warning "Note: Restart your terminal or run 'hash -r' to clear command cache."
    fi
}

cmd_update() {
    local platform="auto"
    local force=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                if [[ ! "$platform" =~ ^(auto|cpu|nvidia|apple)$ ]]; then
                    print_error "Platform must be 'auto', 'cpu', 'nvidia', or 'apple'"
                    exit 1
                fi
                shift 2
                ;;
            -f|--force)
                force=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Usage: ollama-stack update [-p|--platform TYPE] [-f|--force]"
                exit 1
                ;;
        esac
    done
    
    print_header "Updating Ollama Stack"
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
        print_status "Auto-detected platform: $platform"
    else
        print_status "Using specified platform: $platform"
    fi
    
    check_docker
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    # Check if stack is running
    local running_containers=$(docker compose "${compose_files[@]}" ps -q 2>/dev/null | wc -l)
    local was_running=false
    
    if [ "$running_containers" -gt 0 ]; then
        was_running=true
        if [ "$force" != "true" ]; then
            print_warning "The stack is currently running. This update will:"
            print_status "  • Stop all running containers"
            print_status "  • Pull latest Docker images"
            print_status "  • Restart with updated images"
            print_success "  • Keep all data volumes (no data loss)"
            
            read -p "Continue with update? (y/N): " -n 1 -r
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                print_success "Update cancelled."
                exit 0
            fi
        fi
        
        print_status "Stopping running containers..."
        docker compose "${compose_files[@]}" down
    fi
    
    # Pull latest images
    print_status "Pulling latest images..."
    local images_to_update=(
        "ollama/ollama:latest"
        "ghcr.io/open-webui/open-webui:main"
        "ghcr.io/open-webui/mcpo:main"
    )
    
    local pull_failed=false
    for image in "${images_to_update[@]}"; do
        print_status "  Pulling $image..."
        if ! docker pull "$image"; then
            print_warning "Failed to pull $image"
            pull_failed=true
        fi
    done
    
    # Also pull using compose (in case there are platform-specific overrides)
    print_status "Pulling images via compose..."
    if ! docker compose "${compose_files[@]}" pull; then
        print_warning "Some compose images failed to pull, continuing with available images..."
    fi
    
    # Update extensions if any are enabled
    print_status "Updating enabled extensions..."
    for extension_dir in "$EXTENSIONS_DIR"/*; do
        if [ -d "$extension_dir" ]; then
            extension=$(basename "$extension_dir")
            if [ -f "$extension_dir/docker-compose.yml" ] && is_extension_enabled "$extension"; then
                print_status "  Updating extension: $extension"
                cd "$extension_dir"
                docker compose pull 2>/dev/null || print_warning "Failed to pull $extension images"
                cd "$SCRIPT_DIR"
            fi
        fi
    done
    
    if [ "$was_running" = "true" ]; then
        print_status "Restarting stack with updated images..."
        if ! docker compose "${compose_files[@]}" up -d; then
            print_error "Failed to restart stack after update"
            exit 1
        fi
        
        # Wait for services to be ready
        print_status "Waiting for services to be ready..."
        
        # Always check Ollama health - it's required for Open WebUI
        wait_for_service "Ollama" "http://localhost:11434"
        
        wait_for_service "Open WebUI" "http://localhost:8080"
        wait_for_service "MCP Proxy" "http://localhost:8200/docs"
        
        # Restart enabled extensions
        for extension_dir in "$EXTENSIONS_DIR"/*; do
            if [ -d "$extension_dir" ]; then
                extension=$(basename "$extension_dir")
                if [ -f "$extension_dir/docker-compose.yml" ] && is_extension_enabled "$extension"; then
                    print_status "  Restarting extension: $extension"
                    cd "$extension_dir"
                    docker compose up -d 2>/dev/null || print_warning "Failed to restart $extension"
                    cd "$SCRIPT_DIR"
                fi
            fi
        done
    fi
    
    print_success "Update completed successfully!"
    
    if [ "$pull_failed" = "true" ]; then
        print_warning "Note: Some images failed to update. Check your internet connection and try again."
    fi
    
    if [ "$was_running" = "true" ]; then
        print_status "Updated services are now running:"
        print_success "  • Open WebUI: http://localhost:8080"
        print_success "  • Ollama API: http://localhost:11434"
        print_success "  • MCP Proxy: http://localhost:8200"
    else
        print_status "Images updated. Run 'ollama-stack start' to use the updated stack."
    fi
}

show_help() {
    cat << 'EOF'
Ollama Stack - Unified CLI Tool

USAGE:
    ollama-stack <COMMAND> [OPTIONS]

COMMANDS:
    start                Start the core stack
    stop                 Stop the core stack
    status               Show stack and extension status
    logs [service]       View logs (all services or specific service)
    extensions           Manage extensions
    update               Update to latest versions
    uninstall            Completely remove the stack and installation

STACK OPTIONS:
    start:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -s, --skip-models        Skip model download prompts
        -u, --update            Automatically update to latest versions

    stop:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -v, --remove-volumes     Remove volumes (WARNING: deletes all data)

    logs:
        -f, --follow            Follow logs in real-time

    update:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -f, --force             Skip confirmation prompt

    uninstall:
        -f, --force             Skip confirmation prompt
        --remove-volumes        Remove data volumes (deletes all data)
        --remove-images         Remove Docker images (forces re-download)
                               Note: Also removes installation files and PATH modifications

EXTENSION COMMANDS:
    extensions list             List all extensions
    extensions enable <name>    Enable an extension
    extensions disable <name>   Disable an extension
    extensions start <name>     Start an extension
    extensions stop <name>      Stop an extension
    extensions restart <name>   Restart an extension
    extensions logs <name>      View extension logs
    extensions info <name>      Show extension information

EXTENSION OPTIONS:
    start/restart:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)

    logs:
        -f, --follow            Follow logs in real-time

EXAMPLES:
    ollama-stack start                          # Start with auto-detected platform
    ollama-stack start -p nvidia                # Force NVIDIA GPU acceleration
    ollama-stack start --update                 # Start and update to latest versions
    ollama-stack stop --remove-volumes          # Stop and delete all data
    ollama-stack update                         # Update to latest versions
    ollama-stack update --force                 # Update without confirmation
    ollama-stack status                         # Show current status
    ollama-stack logs -f                        # Follow all logs
    ollama-stack logs webui                     # Show WebUI logs only
    ollama-stack uninstall                      # Remove stack and installation (keeps data and images)
    ollama-stack uninstall --remove-volumes     # Remove everything including all data (keeps images)
    ollama-stack uninstall --remove-images      # Remove stack, installation, and Docker images
    ollama-stack uninstall --remove-volumes --remove-images  # Remove everything completely

    ollama-stack extensions list               # List all extensions
    ollama-stack extensions enable dia-tts-mcp # Enable TTS extension
    ollama-stack extensions start dia-tts-mcp  # Start TTS extension
    ollama-stack extensions logs dia-tts-mcp -f # Follow TTS logs

ACCESS POINTS:
    Open WebUI: http://localhost:8080
    Ollama API: http://localhost:11434
    MCP Proxy:  http://localhost:8200
    MCP Docs:   http://localhost:8200/docs

For more information, visit: https://github.com/your-repo/ollama-stack
EOF
}

# Main command dispatcher
main() {
    # Change to script directory
    cd "$SCRIPT_DIR"
    
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case $command in
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        extensions|ext)
            cmd_extensions "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        uninstall)
            cmd_uninstall "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            print_error "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 