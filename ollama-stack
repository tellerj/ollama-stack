#!/bin/bash
# Ollama Stack - Unified CLI Tool
# Combines stack management and extension management into a single interface

set -e

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
EXTENSIONS_DIR="$SCRIPT_DIR/extensions"
REGISTRY_FILE="$EXTENSIONS_DIR/registry.json"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;37m'
NC='\033[0m' # No Color

# Function to print colored output
print_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

print_header() {
    local message=$1
    echo ""
    print_color $CYAN "==== $message ===="
}

print_status() {
    print_color $BLUE "[*] $1"
}

print_success() {
    print_color $GREEN "[+] $1"
}

print_error() {
    print_color $RED "[-] $1"
}

print_warning() {
    print_color $YELLOW "[!] $1"
}

# Platform detection
detect_platform() {
    # Check for Apple Silicon
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if [[ $(uname -m) == "arm64" ]]; then
            echo "apple"
            return
        fi
    fi
    
    # Check for NVIDIA GPU
    if command -v nvidia-smi >/dev/null 2>&1; then
        if nvidia-smi >/dev/null 2>&1; then
            echo "nvidia"
            return
        fi
    fi
    
    # Default to CPU
    echo "cpu"
}

# Check if Docker is running
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running. Please start Docker and try again."
        exit 1
    fi
}

# Wait for service health
wait_for_service() {
    local service_name=$1
    local url=$2
    local max_wait=${3:-120}
    
    print_status "Waiting for $service_name to be ready..."
    local elapsed=0
    
    while [ $elapsed -lt $max_wait ]; do
        if curl -s -f "$url" >/dev/null 2>&1; then
            print_success "$service_name ready!"
            return 0
        fi
        
        sleep 5
        elapsed=$((elapsed + 5))
        print_color $GRAY "   Still waiting... ($elapsed/$max_wait seconds)"
    done
    
    print_error "$service_name failed to start within $max_wait seconds"
    return 1
}

# Get compose files for platform
get_compose_files() {
    local platform=$1
    local compose_files=("-f" "docker-compose.yml")
    
    case $platform in
        nvidia)
            compose_files+=("-f" "docker-compose.nvidia.yml")
            ;;
        apple)
            compose_files+=("-f" "docker-compose.apple.yml")
            ;;
    esac
    
    echo "${compose_files[@]}"
}

# Extension management functions
get_extensions() {
    if [ ! -f "$REGISTRY_FILE" ]; then
        echo "[]"
        return
    fi
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
    print(json.dumps(list(data.get('extensions', {}).keys())))
except:
    print('[]')
"
}

get_enabled_extensions() {
    if [ ! -f "$REGISTRY_FILE" ]; then
        echo "[]"
        return
    fi
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
    print(json.dumps(data.get('enabled', [])))
except:
    print('[]')
"
}

is_extension_enabled() {
    local extension=$1
    local enabled_list=$(get_enabled_extensions)
    echo "$enabled_list" | python3 -c "
import json, sys
enabled = json.load(sys.stdin)
print('true' if '$extension' in enabled else 'false')
"
}

update_registry() {
    local extension=$1
    local action=$2  # enable or disable
    
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
except:
    data = {'version': '1.0', 'extensions': {}, 'enabled': []}

enabled = data.get('enabled', [])
if '$action' == 'enable' and '$extension' not in enabled:
    enabled.append('$extension')
elif '$action' == 'disable' and '$extension' in enabled:
    enabled.remove('$extension')

data['enabled'] = enabled

with open('$REGISTRY_FILE', 'w') as f:
    json.dump(data, f, indent=2)
"
}

# Command implementations

cmd_start() {
    local platform="auto"
    local skip_models=false
    local auto_update=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                if [[ ! "$platform" =~ ^(auto|cpu|nvidia|apple)$ ]]; then
                    print_error "Platform must be 'auto', 'cpu', 'nvidia', or 'apple'"
                    exit 1
                fi
                shift 2
                ;;
            -s|--skip-models)
                skip_models=true
                shift
                ;;
            -u|--update)
                auto_update=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    print_header "Starting Ollama Stack"
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
        print_status "Auto-detected platform: $platform"
    else
        print_status "Using specified platform: $platform"
    fi
    
    check_docker
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    case $platform in
        nvidia)
            print_color $MAGENTA "Using NVIDIA GPU acceleration"
            ;;
        apple)
            print_color $MAGENTA "Using Apple Silicon configuration"
            print_warning "Make sure native Ollama app is running!"
            ;;
        cpu)
            print_color $MAGENTA "Using CPU-only configuration"
            ;;
    esac
    
    # Start core stack
    print_status "Starting core stack..."
    if ! docker compose "${compose_files[@]}" up -d; then
        print_error "Failed to start core stack"
        exit 1
    fi
    
    # Wait for services
    print_status "Waiting for core services..."
    
    if [ "$platform" != "apple" ]; then
        wait_for_service "Ollama" "http://localhost:11434"
    fi
    
    wait_for_service "Open WebUI" "http://localhost:8080"
    wait_for_service "MCP Proxy" "http://localhost:8200/docs"
    
    print_header "Stack Started Successfully!"
    print_color $WHITE "Services:"
    print_color $GREEN "  • Open WebUI: http://localhost:8080"
    if [ "$platform" != "apple" ]; then
        print_color $GREEN "  • Ollama API: http://localhost:11434"
    fi
    print_color $GREEN "  • MCP Proxy: http://localhost:8200"
    print_color $GREEN "  • MCP Docs: http://localhost:8200/docs"
    echo ""
    print_success "Ready! Visit http://localhost:8080 to get started."
}

cmd_stop() {
    local platform="auto"
    local remove_volumes=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                shift 2
                ;;
            -v|--remove-volumes)
                remove_volumes=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    print_header "Stopping Ollama Stack"
    
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    
    check_docker
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    # Build command
    local compose_cmd=("docker" "compose" "${compose_files[@]}")
    
    if [ "$remove_volumes" = true ]; then
        print_warning "Removing volumes (all data will be deleted)..."
        compose_cmd+=("down" "-v")
    else
        compose_cmd+=("down")
    fi
    
    # Execute
    if "${compose_cmd[@]}"; then
        print_success "Stack stopped successfully"
        if [ "$remove_volumes" = true ]; then
            print_success "Volumes removed successfully"
        fi
    else
        print_error "Failed to stop stack"
        exit 1
    fi
}

cmd_status() {
    print_header "Ollama Stack Status"
    
    # Check Docker
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running"
        return 1
    fi
    
    # Check core services
    print_color $CYAN "Core Services:"
    docker compose ps --format "table {{.Service}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || print_warning "No core services running"
    
    # Check extensions
    echo ""
    print_color $CYAN "Extensions:"
    cmd_extensions_list
}

cmd_logs() {
    local service=""
    local follow=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                service="$1"
                shift
                ;;
        esac
    done
    
    if [ -z "$service" ]; then
        # Show all logs
        if [ "$follow" = true ]; then
            docker compose logs -f
        else
            docker compose logs
        fi
    else
        # Show specific service logs
        if [ "$follow" = true ]; then
            docker compose logs -f "$service"
        else
            docker compose logs "$service"
        fi
    fi
}

cmd_extensions() {
    local subcommand="$1"
    shift
    
    case $subcommand in
        list|ls)
            cmd_extensions_list "$@"
            ;;
        enable)
            cmd_extensions_enable "$@"
            ;;
        disable)
            cmd_extensions_disable "$@"
            ;;
        start)
            cmd_extensions_start "$@"
            ;;
        stop)
            cmd_extensions_stop "$@"
            ;;
        restart)
            cmd_extensions_restart "$@"
            ;;
        logs)
            cmd_extensions_logs "$@"
            ;;
        info)
            cmd_extensions_info "$@"
            ;;
        *)
            print_error "Unknown extensions subcommand: $subcommand"
            echo ""
            echo "Available subcommands:"
            echo "  list, ls       List all extensions"
            echo "  enable <ext>   Enable an extension"
            echo "  disable <ext>  Disable an extension"
            echo "  start <ext>    Start an extension"
            echo "  stop <ext>     Stop an extension"
            echo "  restart <ext>  Restart an extension"
            echo "  logs <ext>     View extension logs"
            echo "  info <ext>     Show extension information"
            exit 1
            ;;
    esac
}

cmd_extensions_list() {
    if [ ! -d "$EXTENSIONS_DIR" ]; then
        print_warning "Extensions directory not found"
        return 1
    fi
    
    for ext_dir in "$EXTENSIONS_DIR"/*/; do
        if [ -d "$ext_dir" ]; then
            local ext_name=$(basename "$ext_dir")
            
            # Skip manage.sh and other files
            if [ "$ext_name" = "manage.sh" ] || [ "$ext_name" = "registry.json" ]; then
                continue
            fi
            
            local enabled=$(is_extension_enabled "$ext_name")
            local status_icon="❌"
            local status_text="disabled"
            
            if [ "$enabled" = "true" ]; then
                status_icon="✅"
                status_text="enabled"
                
                # Check if running
                if docker ps --format "table {{.Names}}" | grep -q "^$ext_name\$"; then
                    status_icon="🟢"
                    status_text="running"
                fi
            fi
            
            print_color $WHITE "  $status_icon $ext_name ($status_text)"
            
            # Get description
            if [ -f "$ext_dir/mcp-config.json" ]; then
                local desc=$(python3 -c "
import json
try:
    with open('$ext_dir/mcp-config.json', 'r') as f:
        data = json.load(f)
    print(data.get('description', ''))
except:
    pass
" 2>/dev/null)
                if [ -n "$desc" ]; then
                    print_color $GRAY "      $desc"
                fi
            fi
        fi
    done
}

cmd_extensions_enable() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "true" ]; then
        print_warning "Extension '$extension' is already enabled"
        return 0
    fi
    
    update_registry "$extension" "enable"
    print_success "Extension '$extension' enabled"
}

cmd_extensions_disable() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "false" ]; then
        print_warning "Extension '$extension' is already disabled"
        return 0
    fi
    
    # Stop if running
    if docker ps --format "table {{.Names}}" | grep -q "^$extension\$"; then
        cmd_extensions_stop "$extension"
    fi
    
    update_registry "$extension" "disable"
    print_success "Extension '$extension' disabled"
}

cmd_extensions_start() {
    local extension="$1"
    local platform="auto"
    
    # Parse arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                shift 2
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "false" ]; then
        print_error "Extension '$extension' is not enabled. Enable it first with: ollama-stack extensions enable $extension"
        exit 1
    fi
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    
    print_status "Starting extension '$extension' with $platform configuration..."
    
    # Change to extension directory
    cd "$EXTENSIONS_DIR/$extension"
    
    # Get compose files
    local compose_files=("-f" "docker-compose.yml")
    case $platform in
        nvidia)
            if [ -f "docker-compose.nvidia.yml" ]; then
                compose_files+=("-f" "docker-compose.nvidia.yml")
            fi
            ;;
        apple)
            if [ -f "docker-compose.apple.yml" ]; then
                compose_files+=("-f" "docker-compose.apple.yml")
            fi
            ;;
    esac
    
    # Start extension
    if docker compose "${compose_files[@]}" up -d; then
        print_success "Extension '$extension' started successfully"
    else
        print_error "Failed to start extension '$extension'"
        exit 1
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_stop() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    print_status "Stopping extension '$extension'..."
    
    cd "$EXTENSIONS_DIR/$extension"
    
    if docker compose down; then
        print_success "Extension '$extension' stopped successfully"
    else
        print_error "Failed to stop extension '$extension'"
        exit 1
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_restart() {
    local extension="$1"
    shift
    
    cmd_extensions_stop "$extension"
    cmd_extensions_start "$extension" "$@"
}

cmd_extensions_logs() {
    local extension="$1"
    local follow=false
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    cd "$EXTENSIONS_DIR/$extension"
    
    if [ "$follow" = true ]; then
        docker compose logs -f
    else
        docker compose logs
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_info() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    print_header "Extension Information: $extension"
    
    # Read MCP config
    local config_file="$EXTENSIONS_DIR/$extension/mcp-config.json"
    if [ -f "$config_file" ]; then
        python3 -c "
import json
try:
    with open('$config_file', 'r') as f:
        data = json.load(f)
    
    print(f\"Name: {data.get('displayName', 'N/A')}\")
    print(f\"Version: {data.get('version', 'N/A')}\")
    print(f\"Type: {data.get('type', 'N/A')}\")
    print(f\"Description: {data.get('description', 'N/A')}\")
    print()
    
    # MCP info
    mcp = data.get('mcp', {})
    caps = mcp.get('capabilities', {})
    print('MCP Configuration:')
    print(f\"  Server Name: {mcp.get('serverName', 'N/A')}\")
    print(f\"  Transport: {mcp.get('transport', 'N/A')}\")
    print(f\"  Tools: {'✅' if caps.get('tools') else '❌'}\")
    print(f\"  Resources: {'✅' if caps.get('resources') else '❌'}\")
    print(f\"  Prompts: {'✅' if caps.get('prompts') else '❌'}\")
    print()
    
    # Platform support
    platforms = data.get('platforms', {})
    print('Platform Support:')
    for platform, info in platforms.items():
        supported = '✅' if info.get('supported', False) else '❌'
        perf = info.get('performance', 'unknown')
        print(f\"  {platform}: {supported} (performance: {perf})\")
    print()
    
    # Requirements
    reqs = data.get('requirements', {})
    if reqs:
        print('Requirements:')
        for req, desc in reqs.items():
            if isinstance(desc, dict):
                req_text = desc.get('description', str(desc))
                required = ' (required)' if desc.get('required', False) else ''
                print(f\"  {req}: {req_text}{required}\")
            else:
                print(f\"  {req}: {desc}\")
        print()
    
except Exception as e:
    print(f'Error reading config: {e}')
"
    fi
    
    # Status
    local enabled=$(is_extension_enabled "$extension")
    local running="No"
    if docker ps --format "table {{.Names}}" | grep -q "^$extension\$"; then
        running="Yes"
    fi
    
    print_color $CYAN "Status:"
    print_color $WHITE "  Enabled: $([ "$enabled" = "true" ] && echo "✅ Yes" || echo "❌ No")"
    print_color $WHITE "  Running: $([ "$running" = "Yes" ] && echo "🟢 Yes" || echo "🔴 No")"
}

show_help() {
    cat << 'EOF'
Ollama Stack - Unified CLI Tool

USAGE:
    ollama-stack <COMMAND> [OPTIONS]

COMMANDS:
    start                Start the core stack
    stop                 Stop the core stack
    status               Show stack and extension status
    logs [service]       View logs (all services or specific service)
    extensions           Manage extensions

STACK OPTIONS:
    start:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -s, --skip-models        Skip model download prompts
        -u, --update            Automatically update to latest versions

    stop:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -v, --remove-volumes     Remove volumes (WARNING: deletes all data)

    logs:
        -f, --follow            Follow logs in real-time

EXTENSION COMMANDS:
    extensions list             List all extensions
    extensions enable <name>    Enable an extension
    extensions disable <name>   Disable an extension
    extensions start <name>     Start an extension
    extensions stop <name>      Stop an extension
    extensions restart <name>   Restart an extension
    extensions logs <name>      View extension logs
    extensions info <name>      Show extension information

EXTENSION OPTIONS:
    start/restart:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)

    logs:
        -f, --follow            Follow logs in real-time

EXAMPLES:
    ollama-stack start                          # Start with auto-detected platform
    ollama-stack start -p nvidia                # Force NVIDIA GPU acceleration
    ollama-stack stop --remove-volumes          # Stop and delete all data
    ollama-stack status                         # Show current status
    ollama-stack logs -f                        # Follow all logs
    ollama-stack logs webui                     # Show WebUI logs only

    ollama-stack extensions list               # List all extensions
    ollama-stack extensions enable dia-tts-mcp # Enable TTS extension
    ollama-stack extensions start dia-tts-mcp  # Start TTS extension
    ollama-stack extensions logs dia-tts-mcp -f # Follow TTS logs

ACCESS POINTS:
    Open WebUI: http://localhost:8080
    Ollama API: http://localhost:11434 (except Apple Silicon)
    MCP Proxy:  http://localhost:8200
    MCP Docs:   http://localhost:8200/docs

For more information, visit: https://github.com/your-repo/ollama-stack
EOF
}

# Main command dispatcher
main() {
    # Change to script directory
    cd "$SCRIPT_DIR"
    
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case $command in
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        extensions|ext)
            cmd_extensions "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 