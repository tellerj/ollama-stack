#!/bin/bash
# Ollama Stack - Unified CLI Tool
# Combines stack management and extension management into a single interface

set -e

# Global variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
EXTENSIONS_DIR="$SCRIPT_DIR/extensions"
REGISTRY_FILE="$EXTENSIONS_DIR/registry.json"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color
CYAN='\033[0;36m'

# Function to print colored output
print_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

print_header() {
    local message=$1
    echo ""
    print_color $WHITE "==== $message ===="
}

print_status() {
    print_color $CYAN "[*] $1"
}

print_success() {
    print_color $GREEN "[+] $1"
}

print_error() {
    print_color $RED "[-] $1"
}

print_warning() {
    print_color $YELLOW "[!] $1"
}

# Platform detection
detect_platform() {
    # Check for Apple Silicon
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if [[ $(uname -m) == "arm64" ]]; then
            echo "apple"
            return
        fi
    fi
    
    # Check for NVIDIA GPU
    if command -v nvidia-smi >/dev/null 2>&1; then
        if nvidia-smi >/dev/null 2>&1; then
            echo "nvidia"
            return
        fi
    fi
    
    # Default to CPU
    echo "cpu"
}

# Check for available updates
check_for_updates() {
    local platform="$1"
    
    # Simple check: if images are older than 7 days, suggest update
    local old_images=()
    
    # Check core images based on platform
    local images_to_check=()
    if [ "$platform" != "apple" ]; then
        images_to_check+=("ollama/ollama:latest")
    fi
    images_to_check+=("ghcr.io/open-webui/open-webui:main" "ghcr.io/open-webui/mcpo:main")
    
    for image in "${images_to_check[@]}"; do
        # Check if image is older than 7 days using simple find-like logic
        if docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedSince}}" | grep -q "$image.*[8-9] days ago\|[1-9][0-9] days ago\|[1-9] weeks ago\|[1-9] months ago"; then
            local service_name=$(echo "$image" | cut -d'/' -f2- | cut -d':' -f1)
            old_images+=("$service_name")
        fi
    done
    
    # Display simple notification if old images found
    if [ ${#old_images[@]} -gt 0 ]; then
        print_warning "Some images may have updates available"
        print_status "Run 'ollama-stack update' to get the latest versions"
    fi
}

# Check if Docker is running
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running. Please start Docker and try again."
        exit 1
    fi
}

# Store infrastructure names in .env for reliable operations
store_infrastructure_names() {
    local env_file=".env"
    local project_name=""
    
    # Get current project name (directory name or docker-compose project)
    project_name=$(basename "$(pwd)")
    
    # Add infrastructure naming if not already present
    if [ -f "$env_file" ]; then
        if ! grep -q "^PROJECT_NAME=" "$env_file" 2>/dev/null; then
            echo "" >> "$env_file"
            echo "# Infrastructure naming - exact names for reliable operations" >> "$env_file"
            echo "PROJECT_NAME=${project_name}" >> "$env_file"
            echo "OLLAMA_VOLUME_NAME=${project_name}_ollama_data" >> "$env_file"
            echo "WEBUI_VOLUME_NAME=${project_name}_webui_data" >> "$env_file"
            echo "NETWORK_NAME=${project_name}_network" >> "$env_file"
        fi
        
        # Add or update stack state tracking
        if ! grep -q "^# Stack state tracking" "$env_file" 2>/dev/null; then
            echo "" >> "$env_file"
            echo "# Stack state tracking" >> "$env_file"
        fi
        
        # Update version (remove old if exists, add new)
        grep -v "^STACK_VERSION=" "$env_file" > "${env_file}.tmp" 2>/dev/null || cp "$env_file" "${env_file}.tmp"
        echo "STACK_VERSION=2.1.0" >> "${env_file}.tmp"
        
        # Update detected platform
        local detected_platform=$(detect_platform)
        grep -v "^PLATFORM_DETECTED=" "${env_file}.tmp" > "${env_file}.tmp2" 2>/dev/null || cp "${env_file}.tmp" "${env_file}.tmp2"
        echo "PLATFORM_DETECTED=${detected_platform}" >> "${env_file}.tmp2"
        
        # Update timestamp
        local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u +%Y-%m-%dT%H:%M:%S 2>/dev/null || echo "unknown")
        grep -v "^LAST_UPDATE=" "${env_file}.tmp2" > "${env_file}.tmp3" 2>/dev/null || cp "${env_file}.tmp2" "${env_file}.tmp3"
        echo "LAST_UPDATE=${timestamp}" >> "${env_file}.tmp3"
        
        # Replace original file
        mv "${env_file}.tmp3" "$env_file"
        rm -f "${env_file}.tmp" "${env_file}.tmp2" 2>/dev/null || true
    fi
}

# Smart WEBUI_SECRET_KEY management for fresh vs existing installs
manage_webui_secret_key() {
    # Create .env in the directory where docker-compose files are located (script directory)
    local env_file=".env"
    local webui_volume_exists=false
    local backup_file="${env_file}.backup"
    
    # Validate environment file permissions and backup if needed
    if [ -f "$env_file" ]; then
        if [ ! -w "$env_file" ]; then
            print_warning "Environment file $env_file is not writable"
            return 1
        fi
        # Create backup of existing .env file
        cp "$env_file" "$backup_file" 2>/dev/null || true
    fi
    
    # Check if webui_data volume exists (indicates existing installation)
    # First try to use exact name from .env, fallback to detection for backward compatibility
    local volume_name=""
    if [ -f "$env_file" ] && grep -q "^WEBUI_VOLUME_NAME=" "$env_file" 2>/dev/null; then
        volume_name=$(grep "^WEBUI_VOLUME_NAME=" "$env_file" | cut -d'=' -f2)
        if docker volume ls --format "{{.Name}}" 2>/dev/null | grep -q "^${volume_name}$"; then
            webui_volume_exists=true
        fi
    else
        # Fallback to pattern detection for backward compatibility
        if docker volume ls --format "{{.Name}}" 2>/dev/null | grep -q "webui_data"; then
            webui_volume_exists=true
        fi
    fi
    
    if [ "$webui_volume_exists" = true ]; then
        # Existing installation - ensure we have a persistent key
        local has_key=false
        if [ -f "$env_file" ] && grep -q "^WEBUI_SECRET_KEY=" "$env_file" 2>/dev/null; then
            has_key=true
        fi
        
        if [ "$has_key" = false ]; then
            print_status "Existing installation detected - generating persistent secret key"
            
            # Ensure we can generate a secure key
            if ! command -v openssl >/dev/null 2>&1; then
                print_warning "OpenSSL not found, using fallback key generation"
                local secret_key="ollama-stack-$(date +%s)-$(shuf -i 1000-9999 -n 1 2>/dev/null || echo $RANDOM)"
            else
                local secret_key=$(openssl rand -hex 32 2>/dev/null)
                if [ -z "$secret_key" ]; then
                    print_warning "OpenSSL key generation failed, using fallback"
                    secret_key="ollama-stack-$(date +%s)-$(shuf -i 1000-9999 -n 1 2>/dev/null || echo $RANDOM)"
                fi
            fi
            
            # Add key to .env file
            if echo "WEBUI_SECRET_KEY=$secret_key" >> "$env_file" 2>/dev/null; then
                print_success "Secret key generated and saved to $env_file"
            else
                print_error "Failed to write secret key to $env_file"
                return 1
            fi
        else
            print_status "Using existing secret key for user session persistence"
        fi
    else
        # Fresh installation - no key needed (triggers initial setup screen)
        print_status "Fresh installation detected - initial admin setup will be required"
        
        # Create or clean .env file
        if [ -f "$env_file" ]; then
            # Remove any existing WEBUI_SECRET_KEY to ensure fresh setup
            if grep -v "^WEBUI_SECRET_KEY=" "$env_file" > "$env_file.tmp" 2>/dev/null; then
                mv "$env_file.tmp" "$env_file" 2>/dev/null || {
                    print_warning "Failed to clean existing .env file"
                    rm -f "$env_file.tmp" 2>/dev/null || true
                }
            else
                print_warning "Failed to process existing .env file"
            fi
        else
            # Create new .env file with header
            if ! cat > "$env_file" 2>/dev/null << 'EOF'; then
# Ollama Stack Environment Variables
# This file is automatically managed by ollama-stack
# WEBUI_SECRET_KEY will be generated after initial setup

EOF
                print_error "Failed to create $env_file"
                return 1
            fi
        fi
    fi
    
    # Validate .env file format
    if [ -f "$env_file" ]; then
        if ! validate_env_file "$env_file"; then
            print_warning "Environment file validation failed, restoring backup"
            if [ -f "$backup_file" ]; then
                mv "$backup_file" "$env_file" 2>/dev/null || true
            fi
            return 1
        fi
        # Remove backup if validation successful
        rm -f "$backup_file" 2>/dev/null || true
    fi
    
    return 0
}

# Validate .env file format
validate_env_file() {
    local env_file="$1"
    
    if [ ! -f "$env_file" ]; then
        return 1
    fi
    
    # Check for basic syntax issues
    while IFS= read -r line; do
        # Skip empty lines and comments
        if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
            continue
        fi
        
        # Check for valid KEY=VALUE format
        if [[ ! "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
            print_warning "Invalid line in $env_file: $line"
            return 1
        fi
    done < "$env_file"
    
    return 0
}

# Validate Docker Compose environment integration
validate_compose_environment() {
    local compose_files=("$@")
    
    # Test if docker compose can parse config with current environment
    if ! docker compose "${compose_files[@]}" config >/dev/null 2>&1; then
        print_warning "Docker Compose configuration validation failed"
        return 1
    fi
    
    # Check if WEBUI_SECRET_KEY is properly resolved (only for existing installs)
    local config_output
    if config_output=$(docker compose "${compose_files[@]}" config 2>/dev/null); then
        if echo "$config_output" | grep -q "WEBUI_SECRET_KEY.*\${WEBUI_SECRET_KEY}"; then
            # Variable not resolved - check if it should be
            if [ -f ".env" ] && grep -q "^WEBUI_SECRET_KEY=" ".env"; then
                print_warning "WEBUI_SECRET_KEY variable not resolved by Docker Compose"
                return 1
            fi
        fi
    fi
    
    return 0
}

# Wait for service health
wait_for_service() {
    local service_name=$1
    local url=$2
    local max_wait=${3:-120}
    
    print_status "Waiting for $service_name to be ready..."
    local elapsed=0
    
    while [ $elapsed -lt $max_wait ]; do
        if curl -s -f "$url" >/dev/null 2>&1; then
            print_success "$service_name ready!"
            return 0
        fi
        
        sleep 5
        elapsed=$((elapsed + 5))
        print_status "Still waiting... ($elapsed/$max_wait seconds)"
    done
    
    print_error "$service_name failed to start within $max_wait seconds"
    return 1
}

# Get compose files for platform
get_compose_files() {
    local platform=$1
    local compose_files=("-f" "docker-compose.yml")
    
    case $platform in
        nvidia)
            compose_files+=("-f" "docker-compose.nvidia.yml")
            ;;
        apple)
            compose_files+=("-f" "docker-compose.apple.yml")
            ;;
    esac
    
    echo "${compose_files[@]}"
}

# Extension management functions
get_extensions() {
    if [ ! -f "$REGISTRY_FILE" ]; then
        echo "[]"
        return
    fi
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
    print(json.dumps(list(data.get('extensions', {}).keys())))
except:
    print('[]')
"
}

get_enabled_extensions() {
    if [ ! -f "$REGISTRY_FILE" ]; then
        echo "[]"
        return
    fi
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
    print(json.dumps(data.get('enabled', [])))
except:
    print('[]')
"
}

is_extension_enabled() {
    local extension=$1
    local enabled_list=$(get_enabled_extensions)
    echo "$enabled_list" | python3 -c "
import json, sys
enabled = json.load(sys.stdin)
print('true' if '$extension' in enabled else 'false')
"
}

update_registry() {
    local extension=$1
    local action=$2  # enable or disable
    
    python3 -c "
import json
try:
    with open('$REGISTRY_FILE', 'r') as f:
        data = json.load(f)
except:
    data = {'version': '1.0', 'extensions': {}, 'enabled': []}

enabled = data.get('enabled', [])
if '$action' == 'enable' and '$extension' not in enabled:
    enabled.append('$extension')
elif '$action' == 'disable' and '$extension' in enabled:
    enabled.remove('$extension')

data['enabled'] = enabled

with open('$REGISTRY_FILE', 'w') as f:
    json.dump(data, f, indent=2)
"
}

# Command implementations

cmd_start() {
    local platform="auto"
    local skip_models=false
    local auto_update=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                if [[ ! "$platform" =~ ^(auto|cpu|nvidia|apple)$ ]]; then
                    print_error "Platform must be 'auto', 'cpu', 'nvidia', or 'apple'"
                    exit 1
                fi
                shift 2
                ;;
            -s|--skip-models)
                skip_models=true
                shift
                ;;
            -u|--update)
                auto_update=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    print_header "Starting Ollama Stack"
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
        print_status "Auto-detected platform: $platform"
    else
        print_status "Using specified platform: $platform"
    fi
    
    check_docker
    
    # Store infrastructure names for reliable operations
    store_infrastructure_names
    
    # Smart WEBUI_SECRET_KEY management for fresh vs existing installs
    if ! manage_webui_secret_key; then
        print_error "Failed to manage environment configuration"
        print_status "You can manually create a .env file or run with --skip-env-check (not implemented)"
        exit 1
    fi
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    # Verify Docker Compose can read environment
    if ! validate_compose_environment "${compose_files[@]}"; then
        print_warning "Environment validation failed, but continuing..."
    fi
    
    case $platform in
        nvidia)
            print_status "Using NVIDIA GPU acceleration"
            ;;
        apple)
            print_status "Using Apple Silicon configuration"
            print_warning "Make sure native Ollama app is running!"
            ;;
        cpu)
            print_status "Using CPU-only configuration"
            ;;
    esac
    
    # Start core stack
    print_status "Starting core stack..."
    
    # Pull latest images if update flag is set
    if [ "$auto_update" = "true" ]; then
        print_status "Pulling latest images..."
        if ! docker compose "${compose_files[@]}" pull; then
            print_warning "Failed to pull some images, continuing with existing images..."
        fi
    fi
    
    if ! docker compose "${compose_files[@]}" up -d; then
        print_error "Failed to start core stack"
        exit 1
    fi
    
    # Wait for services
    print_status "Waiting for core services..."
    
    # Always check Ollama health - it's required for Open WebUI
    wait_for_service "Ollama" "http://localhost:11434"
    
    wait_for_service "Open WebUI" "http://localhost:8080"
    wait_for_service "MCP Proxy" "http://localhost:8200/docs"
    
    print_header "Stack Started Successfully!"
    print_status "Services:"
    print_success "  • Open WebUI: http://localhost:8080"
    print_success "  • Ollama API: http://localhost:11434"
    print_success "  • MCP Proxy: http://localhost:8200"
    print_success "  • MCP Docs: http://localhost:8200/docs"
    print_success "Ready! Visit http://localhost:8080 to get started."
    
    # Check for updates if we didn't just update
    if [ "$auto_update" != "true" ]; then
        check_for_updates "$platform"
    fi
}

cmd_stop() {
    local platform="auto"
    local remove_volumes=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                shift 2
                ;;
            -v|--remove-volumes)
                remove_volumes=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    print_header "Stopping Ollama Stack"
    
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    
    check_docker
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    # Build command
    local compose_cmd=("docker" "compose" "${compose_files[@]}")
    
    if [ "$remove_volumes" = true ]; then
        print_warning "Removing volumes (all data will be deleted)..."
        compose_cmd+=("down" "-v")
    else
        compose_cmd+=("down")
    fi
    
    # Execute
    if "${compose_cmd[@]}"; then
        print_success "Stack stopped successfully"
        if [ "$remove_volumes" = true ]; then
            print_success "Volumes removed successfully"
        fi
    else
        print_error "Failed to stop stack"
        exit 1
    fi
}

cmd_status() {
    print_header "Ollama Stack Status"
    
    # Check Docker
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running"
        return 1
    fi
    
    # Check for zombie containers from other installations
    local current_containers=$(docker compose ps -q 2>/dev/null | xargs -I {} docker inspect --format '{{.Name}}' {} 2>/dev/null | sed 's/^\/*//' || true)
    local all_containers=$(docker ps -a --format "{{.Names}}" | grep -E "(webui|ollama|mcp_proxy)" 2>/dev/null || true)
    
    local zombie_containers=""
    for container in $all_containers; do
        if [[ ! "$current_containers" =~ (^|[[:space:]])$container($|[[:space:]]) ]]; then
            if [ -z "$zombie_containers" ]; then
                zombie_containers="$container"
            else
                zombie_containers="$zombie_containers $container"
            fi
        fi
    done
    
    if [ -n "$zombie_containers" ]; then
        print_warning "Found containers from other installations:"
        for container in $zombie_containers; do
            local status=$(docker ps -a --format "{{.Status}}" --filter "name=$container" 2>/dev/null)
            local ports=$(docker ps -a --format "{{.Ports}}" --filter "name=$container" 2>/dev/null)
            print_status "  • $container ($status) $ports"
        done
        print_status "Use 'ollama-stack cleanup' to remove orphaned resources"
        echo ""
    fi
    
    # Check core services
    print_status "Core Services:"
    local core_services=$(docker compose ps --format "table {{.Service}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null)
    if [ -n "$core_services" ]; then
        echo "$core_services"
    else
        print_warning "No core services running"
    fi
    
    # Check for orphaned volumes
    local all_ollama_volumes=$(docker volume ls --format "table {{.Name}}" | grep -E "(ollama|webui)" | grep -v "ollama-stack-1" 2>/dev/null || true)
    if [ -n "$all_ollama_volumes" ]; then
        print_warning "Found volumes from other installations:"
        echo "$all_ollama_volumes" | sed 's/^/  /'
        print_status "Use 'ollama-stack cleanup --volumes' to remove them"
        echo ""
    fi
    
    # Check extensions
    print_status "Extensions:"
    cmd_extensions_list
}

cmd_logs() {
    local service=""
    local follow=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                service="$1"
                shift
                ;;
        esac
    done
    
    if [ -z "$service" ]; then
        # Show all logs
        if [ "$follow" = true ]; then
            docker compose logs -f
        else
            docker compose logs
        fi
    else
        # Show specific service logs
        if [ "$follow" = true ]; then
            docker compose logs -f "$service"
        else
            docker compose logs "$service"
        fi
    fi
}

cmd_extensions() {
    local subcommand="$1"
    shift
    
    case $subcommand in
        list|ls)
            cmd_extensions_list "$@"
            ;;
        enable)
            cmd_extensions_enable "$@"
            ;;
        disable)
            cmd_extensions_disable "$@"
            ;;
        start)
            cmd_extensions_start "$@"
            ;;
        stop)
            cmd_extensions_stop "$@"
            ;;
        restart)
            cmd_extensions_restart "$@"
            ;;
        logs)
            cmd_extensions_logs "$@"
            ;;
        info)
            cmd_extensions_info "$@"
            ;;
        *)
            print_error "Unknown extensions subcommand: $subcommand"
            echo ""
            echo "Available subcommands:"
            echo "  list, ls       List all extensions"
            echo "  enable <ext>   Enable an extension"
            echo "  disable <ext>  Disable an extension"
            echo "  start <ext>    Start an extension"
            echo "  stop <ext>     Stop an extension"
            echo "  restart <ext>  Restart an extension"
            echo "  logs <ext>     View extension logs"
            echo "  info <ext>     Show extension information"
            exit 1
            ;;
    esac
}

cmd_extensions_list() {
    if [ ! -d "$EXTENSIONS_DIR" ]; then
        print_warning "Extensions directory not found"
        return 1
    fi
    
    for ext_dir in "$EXTENSIONS_DIR"/*/; do
        if [ -d "$ext_dir" ]; then
            local ext_name=$(basename "$ext_dir")
            
            # Skip manage.sh and other files
            if [ "$ext_name" = "manage.sh" ] || [ "$ext_name" = "registry.json" ]; then
                continue
            fi
            
            local enabled=$(is_extension_enabled "$ext_name")
            local status_icon="[DISABLED]"
            local status_text="disabled"
            
            if [ "$enabled" = "true" ]; then
                status_icon="[ENABLED]"
                status_text="enabled"
                
                # Check if running
                if docker ps --format "table {{.Names}}" | grep -q "^$ext_name\$"; then
                    status_icon="[RUNNING]"
                    status_text="running"
                fi
            fi
            
            print_status "  $status_icon $ext_name ($status_text)"
            
            # Get description
            if [ -f "$ext_dir/mcp-config.json" ]; then
                local desc=$(python3 -c "
import json
try:
    with open('$ext_dir/mcp-config.json', 'r') as f:
        data = json.load(f)
    print(data.get('description', ''))
except:
    pass
" 2>/dev/null)
                if [ -n "$desc" ]; then
                    print_status "      $desc"
                fi
            fi
        fi
    done
}

cmd_extensions_enable() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "true" ]; then
        print_warning "Extension '$extension' is already enabled"
        return 0
    fi
    
    update_registry "$extension" "enable"
    print_success "Extension '$extension' enabled"
}

cmd_extensions_disable() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "false" ]; then
        print_warning "Extension '$extension' is already disabled"
        return 0
    fi
    
    # Stop if running
    if docker ps --format "table {{.Names}}" | grep -q "^$extension\$"; then
        cmd_extensions_stop "$extension"
    fi
    
    update_registry "$extension" "disable"
    print_success "Extension '$extension' disabled"
}

cmd_extensions_start() {
    local extension="$1"
    local platform="auto"
    
    # Parse arguments
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                shift 2
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    if [ "$(is_extension_enabled "$extension")" = "false" ]; then
        print_error "Extension '$extension' is not enabled. Enable it first with: ollama-stack extensions enable $extension"
        exit 1
    fi
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    
    print_status "Starting extension '$extension' with $platform configuration..."
    
    # Change to extension directory
    cd "$EXTENSIONS_DIR/$extension"
    
    # Get compose files
    local compose_files=("-f" "docker-compose.yml")
    case $platform in
        nvidia)
            if [ -f "docker-compose.nvidia.yml" ]; then
                compose_files+=("-f" "docker-compose.nvidia.yml")
            fi
            ;;
        apple)
            if [ -f "docker-compose.apple.yml" ]; then
                compose_files+=("-f" "docker-compose.apple.yml")
            fi
            ;;
    esac
    
    # Start extension
    if docker compose "${compose_files[@]}" up -d; then
        print_success "Extension '$extension' started successfully"
    else
        print_error "Failed to start extension '$extension'"
        exit 1
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_stop() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    print_status "Stopping extension '$extension'..."
    
    cd "$EXTENSIONS_DIR/$extension"
    
    if docker compose down; then
        print_success "Extension '$extension' stopped successfully"
    else
        print_error "Failed to stop extension '$extension'"
        exit 1
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_restart() {
    local extension="$1"
    shift
    
    cmd_extensions_stop "$extension"
    cmd_extensions_start "$extension" "$@"
}

cmd_extensions_logs() {
    local extension="$1"
    local follow=false
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    cd "$EXTENSIONS_DIR/$extension"
    
    if [ "$follow" = true ]; then
        docker compose logs -f
    else
        docker compose logs
    fi
    
    cd "$SCRIPT_DIR"
}

cmd_extensions_info() {
    local extension="$1"
    if [ -z "$extension" ]; then
        print_error "Extension name required"
        exit 1
    fi
    
    if [ ! -d "$EXTENSIONS_DIR/$extension" ]; then
        print_error "Extension '$extension' not found"
        exit 1
    fi
    
    print_header "Extension Information: $extension"
    
    # Read MCP config
    local config_file="$EXTENSIONS_DIR/$extension/mcp-config.json"
    if [ -f "$config_file" ]; then
        python3 -c "
import json
try:
    with open('$config_file', 'r') as f:
        data = json.load(f)
    
    print(f\"Name: {data.get('displayName', 'N/A')}\")
    print(f\"Version: {data.get('version', 'N/A')}\")
    print(f\"Type: {data.get('type', 'N/A')}\")
    print(f\"Description: {data.get('description', 'N/A')}\")
    print()
    
    # MCP info
    mcp = data.get('mcp', {})
    caps = mcp.get('capabilities', {})
    print('MCP Configuration:')
    print(f\"  Server Name: {mcp.get('serverName', 'N/A')}\")
    print(f\"  Transport: {mcp.get('transport', 'N/A')}\")
    print(f\"  Tools: {'Yes' if caps.get('tools') else 'No'}\")
    print(f\"  Resources: {'Yes' if caps.get('resources') else 'No'}\")
    print(f\"  Prompts: {'Yes' if caps.get('prompts') else 'No'}\")
    print()
    
    # Platform support
    platforms = data.get('platforms', {})
    print('Platform Support:')
    for platform, info in platforms.items():
        supported = 'Yes' if info.get('supported', False) else 'No'
        perf = info.get('performance', 'unknown')
        print(f\"  {platform}: {supported} (performance: {perf})\")
    print()
    
    # Requirements
    reqs = data.get('requirements', {})
    if reqs:
        print('Requirements:')
        for req, desc in reqs.items():
            if isinstance(desc, dict):
                req_text = desc.get('description', str(desc))
                required = ' (required)' if desc.get('required', False) else ''
                print(f\"  {req}: {req_text}{required}\")
            else:
                print(f\"  {req}: {desc}\")
        print()
    
except Exception as e:
    print(f'Error reading config: {e}')
"
    fi
    
    # Status
    local enabled=$(is_extension_enabled "$extension")
    local running="No"
    if docker ps --format "table {{.Names}}" | grep -q "^$extension\$"; then
        running="Yes"
    fi
    
    print_status "Status:"
    print_status "  Enabled: $([ "$enabled" = "true" ] && echo "Yes" || echo "No")"
    print_status "  Running: $([ "$running" = "Yes" ] && echo "Yes" || echo "No")"
}

cmd_uninstall() {
    local force=false
    local remove_volumes=false
    local remove_images=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--force)
                force=true
                shift
                ;;
            --remove-volumes)
                remove_volumes=true
                shift
                ;;
            --remove-images)
                remove_images=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Usage: ollama-stack uninstall [--force] [--remove-volumes] [--remove-images]"
                exit 1
                ;;
        esac
    done
    
    print_header "Ollama Stack Uninstall"
    
    # Detect if we're running from an installed location
    local is_installed=false
    local install_type=""
    local install_path=""
    local project_path=""
    
    # Check common installation locations
    if [[ "$SCRIPT_DIR" == "/usr/local/share/ollama-stack" || "$SCRIPT_DIR" == "$HOME/.local/share/ollama-stack" ]]; then
        is_installed=true
        project_path="$SCRIPT_DIR"
        if [[ "$SCRIPT_DIR" == "/usr/local/share/ollama-stack" ]]; then
            install_type="system"
            install_path="/usr/local/bin/ollama-stack"
        else
            install_type="user"
            install_path="$HOME/.local/bin/ollama-stack"
        fi
    fi
    
    if [ "$force" != "true" ]; then
        print_warning "This will completely remove the Ollama Stack:"
        print_status "  • Stop all running containers"
        print_status "  • Remove all containers"
        if [ "$remove_images" = "true" ]; then
            print_status "  • Remove all Docker images"
        else
            print_success "  • Keep Docker images (faster future installs)"
        fi
        print_status "  • Remove Docker network"
        if [ "$remove_volumes" = "true" ]; then
            print_error "  • Remove all volumes (DELETES ALL DATA!)"
        else
            print_success "  • Keep volumes (data preserved)"
        fi
        print_status "  • Disable all extensions"
        
        if [ "$is_installed" = "true" ]; then
            print_status "  • Remove installation files"
            print_status "  • Remove ollama-stack command"
            print_status "  • Clean up shell PATH modifications"
        fi
        
        read -p "Are you sure you want to continue? (y/N): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_success "Uninstall cancelled."
            exit 0
        fi
    fi
    
    # Stop all services first
    print_status "Stopping all services..."
    cmd_stop --platform auto
    
    # Stop and remove extension containers
    print_status "Stopping and removing extension containers..."
    for extension_dir in "$EXTENSIONS_DIR"/*; do
        if [ -d "$extension_dir" ]; then
            extension=$(basename "$extension_dir")
            if [ -f "$extension_dir/docker-compose.yml" ]; then
                print_status "  Removing extension: $extension"
                cd "$extension_dir"
                docker compose down --remove-orphans 2>/dev/null || true
                cd "$SCRIPT_DIR"
                
                # Disable extension
                update_registry "$extension" "disable"
            fi
        fi
    done
    
    # Remove main stack containers
    print_status "Removing main stack containers..."
    docker compose down --remove-orphans 2>/dev/null || true
    
    # Remove images if requested
    if [ "$remove_images" = "true" ]; then
        print_status "Removing Docker images..."
        local images_to_remove=(
            "ollama/ollama"
            "ghcr.io/open-webui/open-webui"
            "ghcr.io/open-webui/mcpo"
        )
        
        for image in "${images_to_remove[@]}"; do
            if docker images --format "table {{.Repository}}:{{.Tag}}" | grep -q "^$image"; then
                print_status "  Removing image: $image"
                docker rmi $(docker images "$image" -q) 2>/dev/null || true
            fi
        done
        
        # Remove extension images
        for extension_dir in "$EXTENSIONS_DIR"/*; do
            if [ -d "$extension_dir" ]; then
                extension=$(basename "$extension_dir")
                if docker images --format "table {{.Repository}}:{{.Tag}}" | grep -q "^$extension"; then
                    print_status "  Removing extension image: $extension"
                    docker rmi $(docker images "$extension" -q) 2>/dev/null || true
                fi
            fi
        done
    else
        print_status "Keeping Docker images for faster future installs..."
    fi
    
    # Remove volumes
    if [ "$remove_volumes" = "true" ]; then
        print_status "Removing volumes..."
        
        # Find volumes using exact names from .env if available, fallback to patterns
        local project_volumes=""
        local all_volumes=$(docker volume ls --format "{{.Name}}" 2>/dev/null || true)
        
        # Try to get exact volume names from .env first
        if [ -f ".env" ]; then
            local ollama_volume=$(grep "^OLLAMA_VOLUME_NAME=" ".env" 2>/dev/null | cut -d'=' -f2)
            local webui_volume=$(grep "^WEBUI_VOLUME_NAME=" ".env" 2>/dev/null | cut -d'=' -f2)
            
            if [ -n "$ollama_volume" ] && echo "$all_volumes" | grep -q "^${ollama_volume}$"; then
                project_volumes="$project_volumes $ollama_volume"
            fi
            if [ -n "$webui_volume" ] && echo "$all_volumes" | grep -q "^${webui_volume}$"; then
                project_volumes="$project_volumes $webui_volume"
            fi
        fi
        
        # Fallback to pattern matching for backward compatibility
        if [ -z "$project_volumes" ]; then
            project_volumes=$(echo "$all_volumes" | grep -E "(ollama-stack.*ollama_data|ollama-stack.*webui_data|.*_ollama_data|.*_webui_data)" 2>/dev/null || true)
        fi
        
        if [ -n "$project_volumes" ]; then
            while IFS= read -r volume; do
                if [ -n "$volume" ]; then
                    print_status "  Removing volume: $volume"
                    docker volume rm "$volume" 2>/dev/null || true
                fi
            done <<< "$project_volumes"
        else
            print_status "  No ollama-stack volumes found"
        fi
        
        # Remove extension volumes
        for extension_dir in "$EXTENSIONS_DIR"/*; do
            if [ -d "$extension_dir" ]; then
                extension=$(basename "$extension_dir")
                # Look for volumes with extension name prefix
                docker volume ls --format "table {{.Name}}" | grep "^${extension}" | while read -r volume; do
                    if [ ! -z "$volume" ]; then
                        print_status "  Removing extension volume: $volume"
                        docker volume rm "$volume" 2>/dev/null || true
                    fi
                done
            fi
        done
    fi
    
    # Remove network
    print_status "Removing Docker network..."
    local network_name="ollama-stack-network"  # default fallback
    
    # Try to get exact network name from .env
    if [ -f ".env" ]; then
        local env_network_name=$(grep "^NETWORK_NAME=" ".env" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$env_network_name" ]; then
            network_name="$env_network_name"
        fi
    fi
    
    if docker network ls --format "table {{.Name}}" | grep -q "^${network_name}\$"; then
        docker network rm "$network_name" 2>/dev/null || true
    fi
    
    # Clean up any remaining containers
    print_status "Cleaning up remaining containers..."
    docker container prune -f 2>/dev/null || true
    
    # Clean up installation files if installed
    if [ "$is_installed" = "true" ]; then
        print_status "Removing installation files..."
        
        # Remove the wrapper script
        if [ -f "$install_path" ]; then
            print_status "  Removing command: $install_path"
            rm -f "$install_path" 2>/dev/null || true
        fi
        
        # Clean up generated files in project directory
        if [ -d "$project_path" ]; then
            print_status "  Removing generated files (.env, backups)"
            rm -f "$project_path/.env" "$project_path/.env.backup" 2>/dev/null || true
        fi
        
        # Clean up shell PATH modifications
        if [ "$install_type" = "user" ]; then
            print_status "  Cleaning up shell PATH modifications"
            local bin_dir="$(dirname "$install_path")"
            
            # Remove from common shell config files
            for config_file in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
                if [ -f "$config_file" ] && grep -q "$bin_dir" "$config_file"; then
                    print_status "    Removing from $(basename "$config_file")"
                    # Remove the export line and the comment above it
                    sed -i.bak '/# Added by ollama-stack installer/,+1d' "$config_file" 2>/dev/null || true
                    rm -f "$config_file.bak" 2>/dev/null || true
                fi
            done
        fi
        
        # Remove project files (this will remove the directory we're running from)
        # We need to do this last and handle it carefully
        if [ -d "$project_path" ]; then
            print_status "  Removing project files: $project_path"
            
            # Create a temporary cleanup script to remove the project directory
            # after this script exits
            local cleanup_script="/tmp/ollama-stack-cleanup-$$"
            cat > "$cleanup_script" << EOF
#!/bin/bash
sleep 1
rm -rf "$project_path" 2>/dev/null || true
rm -f "$cleanup_script" 2>/dev/null || true
EOF
            chmod +x "$cleanup_script"
            nohup "$cleanup_script" >/dev/null 2>&1 &
        fi
    fi
    
    print_success "Ollama Stack uninstall completed!"
    if [ "$remove_volumes" != "true" ]; then
        print_warning "Note: Data volumes were preserved. Use 'docker volume ls' to see them."
    fi
    
    if [ "$is_installed" = "true" ]; then
        print_success "Installation files removed!"
        print_warning "Note: Restart your terminal or run 'hash -r' to clear command cache."
    fi
}

cmd_cleanup() {
    local remove_volumes=false
    local force=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --volumes)
                remove_volumes=true
                shift
                ;;
            -f|--force)
                force=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Usage: ollama-stack cleanup [--volumes] [--force]"
                exit 1
                ;;
        esac
    done
    
    print_header "Ollama Stack Cleanup"
    
    # Check Docker
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running"
        return 1
    fi
    
    # Find all ollama-stack related containers (including stopped ones)
    local all_containers=$(docker ps -a --format "{{.Names}}" | grep -E "(webui|ollama|mcp_proxy)" 2>/dev/null || true)
    local current_containers=$(docker compose ps -q 2>/dev/null | xargs -I {} docker inspect --format '{{.Name}}' {} 2>/dev/null | sed 's/^\/*//' || true)
    
    # Find zombie containers (not managed by current compose)
    local zombie_containers=""
    for container in $all_containers; do
        if [[ ! "$current_containers" =~ "$container" ]]; then
            zombie_containers="$zombie_containers $container"
        fi
    done
    
    # Find orphaned volumes using exact names if available, fallback to patterns
    local orphaned_volumes=""
    local all_volumes=$(docker volume ls --format "{{.Name}}" 2>/dev/null || true)
    
    # Try to get exact volume names from .env first
    if [ -f ".env" ]; then
        local ollama_volume=$(grep "^OLLAMA_VOLUME_NAME=" ".env" 2>/dev/null | cut -d'=' -f2)
        local webui_volume=$(grep "^WEBUI_VOLUME_NAME=" ".env" 2>/dev/null | cut -d'=' -f2)
        
        if [ -n "$ollama_volume" ] && echo "$all_volumes" | grep -q "^${ollama_volume}$"; then
            orphaned_volumes="$orphaned_volumes $ollama_volume"
        fi
        if [ -n "$webui_volume" ] && echo "$all_volumes" | grep -q "^${webui_volume}$"; then
            orphaned_volumes="$orphaned_volumes $webui_volume"
        fi
    fi
    
    # Fallback to pattern matching if no exact names found
    if [ -z "$orphaned_volumes" ]; then
        orphaned_volumes=$(echo "$all_volumes" | grep -E "(ollama-stack.*ollama_data|ollama-stack.*webui_data|.*_ollama_data|.*_webui_data)" 2>/dev/null || true)
    fi
    
    # Find orphaned networks
    local orphaned_networks=$(docker network ls --format "{{.Name}}" | grep "ollama" | grep -v "ollama-stack-network" 2>/dev/null || true)
    
    if [ -z "$zombie_containers" ] && [ -z "$orphaned_volumes" ] && [ -z "$orphaned_networks" ]; then
        print_success "No orphaned ollama-stack resources found!"
        return 0
    fi
    
    print_warning "Found orphaned ollama-stack resources:"
    
    if [ -n "$zombie_containers" ]; then
        print_status "Containers from other installations:"
        for container in $zombie_containers; do
            local status=$(docker ps -a --format "{{.Status}}" --filter "name=$container" 2>/dev/null)
            print_status "  • $container ($status)"
        done
    fi
    
    if [ -n "$orphaned_volumes" ] && [ "$remove_volumes" = "true" ]; then
        print_error "Volumes to remove (THIS WILL DELETE DATA!):"
        for volume in $orphaned_volumes; do
            print_error "  • $volume"
        done
    elif [ -n "$orphaned_volumes" ]; then
        print_status "Volumes found (use --volumes to remove):"
        for volume in $orphaned_volumes; do
            print_status "  • $volume"
        done
    fi
    
    if [ -n "$orphaned_networks" ]; then
        print_status "Networks to remove:"
        for network in $orphaned_networks; do
            print_status "  • $network"
        done
    fi
    
    if [ "$force" != "true" ]; then
        echo ""
        read -p "Remove these orphaned resources? (y/N): " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_success "Cleanup cancelled."
            exit 0
        fi
    fi
    
    # Remove zombie containers
    if [ -n "$zombie_containers" ]; then
        print_status "Removing orphaned containers..."
        for container in $zombie_containers; do
            print_status "  Stopping and removing: $container"
            docker stop "$container" 2>/dev/null || true
            docker rm "$container" 2>/dev/null || true
        done
    fi
    
    # Remove orphaned volumes if requested
    if [ -n "$orphaned_volumes" ] && [ "$remove_volumes" = "true" ]; then
        print_status "Removing orphaned volumes..."
        for volume in $orphaned_volumes; do
            print_status "  Removing volume: $volume"
            docker volume rm "$volume" 2>/dev/null || true
        done
    fi
    
    # Remove orphaned networks
    if [ -n "$orphaned_networks" ]; then
        print_status "Removing orphaned networks..."
        for network in $orphaned_networks; do
            print_status "  Removing network: $network"
            docker network rm "$network" 2>/dev/null || true
        done
    fi
    
    print_success "Cleanup completed!"
    
    if [ -n "$orphaned_volumes" ] && [ "$remove_volumes" != "true" ]; then
        print_warning "Note: Volumes were preserved. Use 'ollama-stack cleanup --volumes' to remove them."
    fi
}

cmd_update() {
    local platform="auto"
    local force=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--platform)
                platform="$2"
                if [[ ! "$platform" =~ ^(auto|cpu|nvidia|apple)$ ]]; then
                    print_error "Platform must be 'auto', 'cpu', 'nvidia', or 'apple'"
                    exit 1
                fi
                shift 2
                ;;
            -f|--force)
                force=true
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Usage: ollama-stack update [-p|--platform TYPE] [-f|--force]"
                exit 1
                ;;
        esac
    done
    
    print_header "Updating Ollama Stack"
    
    # Detect platform
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
        print_status "Auto-detected platform: $platform"
    else
        print_status "Using specified platform: $platform"
    fi
    
    check_docker

    # Set up environment (ensures consistent .env state)
    manage_webui_secret_key
    
    # Get compose files
    local compose_files=($(get_compose_files $platform))
    
    # Check if stack is running
    local running_containers=$(docker compose "${compose_files[@]}" ps -q 2>/dev/null | wc -l)
    local was_running=false
    
    if [ "$running_containers" -gt 0 ]; then
        was_running=true
        if [ "$force" != "true" ]; then
            print_warning "The stack is currently running. This update will:"
            print_status "  • Stop all running containers"
            print_status "  • Pull latest Docker images"
            print_status "  • Restart with updated images"
            print_success "  • Keep all data volumes (no data loss)"
            
            read -p "Continue with update? (y/N): " -n 1 -r
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                print_success "Update cancelled."
                exit 0
            fi
        fi
        
        print_status "Stopping running containers..."
        docker compose "${compose_files[@]}" down
    fi
    
    # Pull latest images
    print_status "Pulling latest images..."
    local images_to_update=(
        "ollama/ollama:latest"
        "ghcr.io/open-webui/open-webui:main"
        "ghcr.io/open-webui/mcpo:main"
    )
    
    local pull_failed=false
    for image in "${images_to_update[@]}"; do
        print_status "  Pulling $image..."
        if ! docker pull "$image"; then
            print_warning "Failed to pull $image"
            pull_failed=true
        fi
    done
    
    # Also pull using compose (in case there are platform-specific overrides)
    print_status "Pulling images via compose..."
    if ! docker compose "${compose_files[@]}" pull; then
        print_warning "Some compose images failed to pull, continuing with available images..."
    fi
    
    # Update extensions if any are enabled
    print_status "Updating enabled extensions..."
    for extension_dir in "$EXTENSIONS_DIR"/*; do
        if [ -d "$extension_dir" ]; then
            extension=$(basename "$extension_dir")
            if [ -f "$extension_dir/docker-compose.yml" ] && is_extension_enabled "$extension"; then
                print_status "  Updating extension: $extension"
                cd "$extension_dir"
                docker compose pull 2>/dev/null || print_warning "Failed to pull $extension images"
                cd "$SCRIPT_DIR"
            fi
        fi
    done
    
    if [ "$was_running" = "true" ]; then
        print_status "Restarting stack with updated images..."
        if ! docker compose "${compose_files[@]}" up -d; then
            print_error "Failed to restart stack after update"
            exit 1
        fi
        
        # Wait for services to be ready
        print_status "Waiting for services to be ready..."
        
        # Always check Ollama health - it's required for Open WebUI
        wait_for_service "Ollama" "http://localhost:11434"
        
        wait_for_service "Open WebUI" "http://localhost:8080"
        wait_for_service "MCP Proxy" "http://localhost:8200/docs"
        
        # Restart enabled extensions
        for extension_dir in "$EXTENSIONS_DIR"/*; do
            if [ -d "$extension_dir" ]; then
                extension=$(basename "$extension_dir")
                if [ -f "$extension_dir/docker-compose.yml" ] && is_extension_enabled "$extension"; then
                    print_status "  Restarting extension: $extension"
                    cd "$extension_dir"
                    docker compose up -d 2>/dev/null || print_warning "Failed to restart $extension"
                    cd "$SCRIPT_DIR"
                fi
            fi
        done
    fi
    
    print_success "Update completed successfully!"
    
    if [ "$pull_failed" = "true" ]; then
        print_warning "Note: Some images failed to update. Check your internet connection and try again."
    fi
    
    if [ "$was_running" = "true" ]; then
        print_status "Updated services are now running:"
        print_success "  • Open WebUI: http://localhost:8080"
        print_success "  • Ollama API: http://localhost:11434"
        print_success "  • MCP Proxy: http://localhost:8200"
    else
        print_status "Images updated. Run 'ollama-stack start' to use the updated stack."
    fi
}

show_help() {
    cat << 'EOF'
Ollama Stack - Unified CLI Tool

USAGE:
    ollama-stack <COMMAND> [OPTIONS]

COMMANDS:
    start                Start the core stack
    stop                 Stop the core stack
    status               Show stack and extension status
    logs [service]       View logs (all services or specific service)
    extensions           Manage extensions
    update               Update to latest versions
    cleanup              Remove orphaned containers and resources
    uninstall            Completely remove the stack and installation

STACK OPTIONS:
    start:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -s, --skip-models        Skip model download prompts
        -u, --update            Automatically update to latest versions

    stop:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -v, --remove-volumes     Remove volumes (WARNING: deletes all data)

    logs:
        -f, --follow            Follow logs in real-time

    update:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)
        -f, --force             Skip confirmation prompt

    cleanup:
        --volumes               Also remove orphaned volumes (DELETES DATA!)
        -f, --force             Skip confirmation prompt

    uninstall:
        -f, --force             Skip confirmation prompt
        --remove-volumes        Remove data volumes (deletes all data)
        --remove-images         Remove Docker images (forces re-download)
                               Note: Also removes installation files and PATH modifications

EXTENSION COMMANDS:
    extensions list             List all extensions
    extensions enable <name>    Enable an extension
    extensions disable <name>   Disable an extension
    extensions start <name>     Start an extension
    extensions stop <name>      Stop an extension
    extensions restart <name>   Restart an extension
    extensions logs <name>      View extension logs
    extensions info <name>      Show extension information

EXTENSION OPTIONS:
    start/restart:
        -p, --platform TYPE      Platform: auto, cpu, nvidia, apple (default: auto)

    logs:
        -f, --follow            Follow logs in real-time

EXAMPLES:
    ollama-stack start                          # Start with auto-detected platform
    ollama-stack start -p nvidia                # Force NVIDIA GPU acceleration
    ollama-stack start --update                 # Start and update to latest versions
    ollama-stack stop --remove-volumes          # Stop and delete all data
    ollama-stack update                         # Update to latest versions
    ollama-stack update --force                 # Update without confirmation
    ollama-stack cleanup                        # Remove orphaned containers/networks
    ollama-stack cleanup --volumes              # Also remove orphaned volumes (DANGER!)
    ollama-stack status                         # Show current status
    ollama-stack logs -f                        # Follow all logs
    ollama-stack logs webui                     # Show WebUI logs only
    ollama-stack uninstall                      # Remove stack and installation (keeps data and images)
    ollama-stack uninstall --remove-volumes     # Remove everything including all data (keeps images)
    ollama-stack uninstall --remove-images      # Remove stack, installation, and Docker images
    ollama-stack uninstall --remove-volumes --remove-images  # Remove everything completely

    ollama-stack extensions list               # List all extensions
    ollama-stack extensions enable dia-tts-mcp # Enable TTS extension
    ollama-stack extensions start dia-tts-mcp  # Start TTS extension
    ollama-stack extensions logs dia-tts-mcp -f # Follow TTS logs

ACCESS POINTS:
    Open WebUI: http://localhost:8080
    Ollama API: http://localhost:11434
    MCP Proxy:  http://localhost:8200
    MCP Docs:   http://localhost:8200/docs

For more information, visit: https://github.com/your-repo/ollama-stack
EOF
}

# Main command dispatcher
main() {
    # Change to script directory
    cd "$SCRIPT_DIR"
    
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case $command in
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        extensions|ext)
            cmd_extensions "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        cleanup)
            cmd_cleanup "$@"
            ;;
        uninstall)
            cmd_uninstall "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            print_error "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 